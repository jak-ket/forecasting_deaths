---
title: "Forecasting deaths"
output: html_notebook
---


```{r}
# set up
setwd("~/forecast_hub/forecasting_deaths")
Sys.setlocale(category = "LC_TIME", locale = "English") # control language
source("functions.R")
```

## preprocess data

```{r}
cases_raw <- read.csv("./data-truth/truth_RKI-Incident Cases by Age_Germany.csv")
deaths_raw <- read.csv("./data-truth/truth_RKI-Incident Deaths by Age_Germany.csv")

# restrict to Germany and useful columns only
cases <- subset(cases_raw, location_name=="Germany", select=c(date, age_group, value))
deaths <- subset(deaths_raw, location_name=="Germany", select=c(date, age_group, value))

# reset index
row.names(cases) <- NULL
row.names(deaths) <- NULL

# get age groups
age_groups <- unname(unlist(unique(deaths["age_group"])))
age_groups

# get time series in wide format / age groups in rows
cases_wide <- setNames(reshape(cases, idvar="date", timevar="age_group", direction = "wide"), c("date", age_groups))
deaths_wide <- setNames(reshape(deaths, idvar="date", timevar="age_group", direction = "wide"), c("date", age_groups))

cases_wide$date <- as.Date(cases_wide$date)
deaths_wide$date <- as.Date(deaths_wide$date)

row.names(cases_wide) <- NULL
row.names(deaths_wide) <- NULL

# replace NAs with zero
cases_wide[is.na(cases_wide)] <- 0
deaths_wide[is.na(deaths_wide)] <- 0
```

## configuration and data preparation

```{r}
# CONFIG

# select training period 
# end: give exact date or NA to choose end of time series
start <- as.Date("2020-11-01")
end <- as.Date("2021-02-01") 

# set end date to last available date if end == NA 
if(is.na(end)){end <- cases_wide[dim(cases_wide)[1],"date"]}

# exclude sequence of dates
start_exclude <- as.Date("2020-12-20")
end_exclude <- as.Date("2021-01-22")
dates_excluded <- seq(start_exclude, end_exclude, by="days")

# window for rolling sum (smoothing)
window <- 7
start_after_rolsum <- start + window - 1

# names of parameters to be fitted
# lag and size are essential; case fatality rate could be complemented by other covariates
param_names <- c("lag", "size", "cfr") # dim of is needed later 
```

```{r}
# filter data for training period and calculate rolling sums for all age groups
prepared_data <- prepare_data(cases_wide, deaths_wide, start, end, window)
processed_cases <- prepared_data$cases
processed_deaths <- prepared_data$deaths
```


## calculate best param values for SEVERAL interesting age groups

```{r}
## function arguments ########
# age groups
ags <- c("A35-A59", "A60-A79", "A80+")
# set of lags to optimize over
lags <- 15:35
############################


# store best params for all considered groups
best_params <- matrix(nrow = length(ags), ncol = length(param_names)+1)
colnames(best_params) <- c(param_names, "value")
row.names(best_params) <- ags


# iterate over age groups
for (i in 1:length(ags)){
  ag <- ags[i]
  best_params_ag <- fit_params_ag(age_group = ag, lags = lags, 
                    processed_cases = processed_cases, 
                    processed_deaths = processed_deaths,
                    start = start, end = end, 
                    start_exclude = start_exclude, end_exclude = end_exclude,
                    param_names = param_names, print_plot = T)
  best_params[i,] <- best_params_ag
} 

best_params

```




## estimate dispersion parameter for pooled forecast (all age strata)

```{r}
size_pooled <- get_pooled_size(ags, best_params, processed_cases, processed_deaths, dates_excluded)
size_pooled
```

# estimate 1 and 2 week ahead forecasts and export in hub format

```{r}
wks_ahead <- 1:2 # forecast horizon

## calculate corresponding forecast Saturdays

# get forecast Saturdays after end date 
future_dates <- seq(end, end+max(wks_ahead)*7+6, by="day")
sats <- future_dates[weekdays(future_dates) == "Saturday"]

if(weekdays(end) %in% c("Saturday", "Sunday", "Monday")){
  # 1wk ahead is on next Saturday 
  fc_dates <- sats[-length(sats)]  
} else {
  # 1wk ahead is on Saturday after next Saturday
  fc_dates <- sats[-1]
}

## calculate forecasts
levels <- c(0.01, 0.025, 1:19/20, 0.975, 0.99)

# store quantile forecasts directly in final format table
col_names <- c("forecast_date", "target", "target_end_date", "location", "location_name", "type", "quantile", "value")
entries_per_date <- length(levels)+1 # quantile forecasts + median as point forecast
fc_table <- data.frame(matrix(nrow = (entries_per_date)*length(wks_ahead), ncol = length(col_names)))
colnames(fc_table) <- col_names

# fill in a priori knowledge for all rows / forecast dates
fc_table[,"forecast_date"] <- end
fc_table[,"location"] <- "GM"
fc_table[,"location_name"] <- "Germany"
fc_table[,"type"] <- rep(c(rep("quantile", length(levels)), "point"), length(wks_ahead))
fc_table[,"quantile"] <- rep(c(levels, "NA"), length(wks_ahead))

for(i in 1:length(wks_ahead)){
  wk_ahead <- wks_ahead[i]
  fc_date <- fc_dates[i]
  
  print(paste("Calculate", wk_ahead, "week ahead inc death forecast | target end date: ", fc_date))
  
  # calculate forecast quantiles for current date
  fc_quantiles <- calc_forecast(fc_date = fc_date, best_params = best_params, ags = ags, size_pooled = size_pooled, processed_cases=processed_cases)
  
  # row indices for current forecast date in fc_table
  row_indices <- ((i - 1)*entries_per_date + 1):(i*entries_per_date)
    
  # complement data frame
  fc_table[row_indices,"target"] <- rep(paste(wk_ahead, "wk ahead inc death"), entries_per_date)
  fc_table[row_indices,"target_end_date"] <- fc_date
  fc_table[row_indices,"value"] <- c(fc_quantiles, fc_quantiles["0.5"])
}

fc_table[,"target_end_date"] <- as.Date(fc_table[,"target_end_date"], origin = '1970-01-01')

# write csv
write.csv(fc_table, 
          file = paste0(end,"-Germany-", "KIT-model",".csv"), 
          quote = F, row.names = F)

```













